---
title: "Appendix: An Example Trust Game Run using botex"
format: pdf
---

To explain how botex leverages the oTree infrastructure and large language models (LLMs) to set up bots that are capable to participate in typical online experiments, this section details an experimental run of a short one-shot game at the prompt level.

The experiment used for this demonstration is closely aligned to the trust game analyzed in the paper and introduced into the literature by Berg et al. (1995). Its experimental materials are included in the [project repository](https://github.com/joachim-gassen/accframe) in the `otree/trust` folder.

To run an experiment involving botex bots, after setting up the experiment in oTree, you have to install botex in your python environment. While the procedure to do this will vary by your setup, it should be similar to running this in your terminal:

```         
python -m venv venv
. venv/bin/activate
pip install otree
pip install botex
```

Then, start otree in the folder where the `trust` experiment is located:

```         
otree devserver
```

After otree is running, you can initialize a session involving two bots and start them with this python script:

```{python}
#| eval: false
import botex

trust = botex.init_otree_session(
  config_name = "trust", npart = 2, 
  botex_db = "botex.sqlite3",
  otree_server_url = "http://localhost:8000",
  otree_rest_key = "your otree secret key as set in settings.py"
)

botex.run_bots_on_session(
  session_id = trust['session_id'],
  botex_db = "botex.sqlite3",
  openai_api_key = "Your OpenAI key",
)
```

Running this code will log to the console informing you about the progress (you can influence this behavior by using the Python `logging` module). After completion, you will have the session data available in your oTree instance while the data from the two bots spawned by botex is available in the SQLite database `botex.sqlite3` in your project root.

This data provides detailed information on the run of the experiment. It contains two tables:

-   `participants`: A table containing information on each session participant (bot or human) for all oTree sessions that were initiated by botex (one session with two participants in our case).
-   `conversations`: A table containing all prompts and responses that were exchanged with the LLM over the course of an experimental run.

The participant information can be extracted and displayed as follows

```{python}
import botex
from IPython.display import Markdown
from tabulate import tabulate

# Adjust this to where you stored the botex data 
BOTEX_DB = '../data/exp_runs/app_example.sqlite3'
part = botex.read_participants_from_botex_db(
  botex_db = BOTEX_DB
)
disp_part = [
  [r[v] for v in ('session_name', 'participant_id', 'time_in','time_out')] 
  for r in part
]
Markdown(tabulate(
  disp_part, 
  headers=["Session", "Participant ID", "Time in", "Time out"]
))
```

To understand how botex works, a peek into the conversation data is helpful. For each bot completing an experimental run in an oTree session, there is an observation in the `conversations` table containing the bot's participant ID, the parameters of the bot call and, most importantly, the conversation history as a JSON object in the variable `conversation`. Let's first see how many messages the two conversations have for our example:

```{python}
import json

# Reading conversation data from botex database
conv = botex.read_conversations_from_botex_db(
  botex_db = BOTEX_DB
)
# To identify the participant roles, we scan 
# the conversation data for a question ID
if "id_sent_amount" in conv[0]['conversation']:
  conv_a = 0
  conv_b = 1
else:
  conv_a = 1
  conv_b = 0

# Parsing the conversation history from the JSON strings   
hist_a = json.loads(conv[conv_a]['conversation'])
hist_b = json.loads(conv[conv_b]['conversation'])

print(
  f"The conversation history of participant A (id: {conv[conv_a]['id']}) " + 
  f"contains {len(hist_a)} messages."
)
print(
  f"The conversation history of participant B (id: {conv[conv_b]['id']}) " + 
  f"contains {len(hist_b)} messages."
)
```

Each of these messages has a `role` and a `content`. The role can either be `system` (the system prompt which is stable throughout the conversation), `user` (a prompt send by botex), or `assistant` (the response of the LLM). The first message is always the system prompt:

```{python}
import textwrap
print(textwrap.fill(hist_a[0]['content'], 70))
```

The next message is the first prompt by botex, setting up the stage for the actual experiment. We will focus first on bot A, representing participant A.

```{python}
print(textwrap.fill(hist_a[1]['content'], 70))
```

The third message is the first response of bot A, indicating that it understands its assignment.

```{python}
print(textwrap.fill(hist_a[2]['content'], 70))
```

After this initiation, the content of the first web page is scraped and included in the prompt for the LLM. As the first page contains no particular task (other than clicking the 'next' button), the LLM is solely tasked to summarize the content of the experiment so far.

```{python}
print(textwrap.fill(hist_a[3]['content'], 70))
```

The next message is the response of the LLM summarizing the first page of the experiment.

```{python}
print(textwrap.fill(hist_a[4]['content'], 70))
```

Based on this, botex proceeds to the next page, and scrapes its content. Assuming that it is not a "wait page", it then prompts the LLM, including the summary from before and the content of the next page.

```{python}
print(textwrap.fill(hist_a[5]['content'], 70))
```

As our bot here has been chosen as participant A and now has to decide on the amount that it wants to send, this relatively lengthy prompt provides explicit and detailed guidance on how the response has to be structured. The capability of LLMs to adhere to these formatting requirements is essential for their usability for botex. Let's see how our LLM performs in this regard by looking at its response.

```{python}
print(textwrap.fill(hist_a[6]['content'], 70))
```

The LLM managed to respond in clean JSON format, and provided the amount that it wishes to send to participant B, along with a reason for its choice. Next, botex sends this amount to the web form and clicks the 'next' button, thereby providing the necessary information for oTree to continue.

We now turn to the other bot B, that has been essentially running through the same procedure as bot A, but is now receiving its first post-introduction prompt as participant B:

```{python}
print(textwrap.fill(hist_b[5]['content'], 70))
```

The structure of the prompt is identical to the one that bot A has received but naturally the webpage content differs. What follows is the answer of bot B:

```{python}
print(textwrap.fill(hist_b[6]['content'], 70))
```

Again, botex feeds the response back to oTree. Essentially, this completes the one-shot trust game and the participants proceed to a result page without any task. As in previous messages, botex tasks the bot to summarize the current status of the experiment to proceed.

```{python}
print(textwrap.fill(hist_b[7]['content'], 70))
```

This is the summary of bot B (the summary of bot A looks very similar and is not included here).

```{python}
print(textwrap.fill(hist_b[8]['content'], 70))
```

What follows is a very simple post-experimental questionnaire.

```{python}
print(textwrap.fill(hist_b[9]['content'], 70))
```

The prompt structure is identical to the other prompts tasking the LLM to provide answers. Here is the response of bot B (again answers of bot A are excluded for brevity):

```{python}
print(textwrap.fill(hist_b[10]['content'], 70))
```

The answers are again forwarded to oTree by botex. Then, the final page of the experiment is provided to the bots (here for bot B):

```{python}
print(textwrap.fill(hist_b[11]['content'], 70))
```

As tasked, the bot provides a final summary.

```{python}
print(textwrap.fill(hist_b[12]['content'], 70))
```

Given that the ultimate page contains no 'next' button, botex concludes that the experimental run is complete. It prompts the LLM for any final feedback to conclude the bot run.

```{python}
print(textwrap.fill(hist_b[13]['content'], 70))
```

The bot responds:

```{python}
print(textwrap.fill(hist_b[14]['content'], 70))
```

This concludes the bot run. The data is being stored to the botex SQLite3 database and the bot thread terminates. When all bot threads are terminated, the call of `botex.run_bots_on_session()` returns to the user.
